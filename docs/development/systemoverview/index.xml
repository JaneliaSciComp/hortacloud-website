<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>System Overview on HortaCloud</title><link>https://hortacloud.janelia.org/docs/development/systemoverview/</link><description>Recent content in System Overview on HortaCloud</description><generator>Hugo</generator><language>en</language><atom:link href="https://hortacloud.janelia.org/docs/development/systemoverview/index.xml" rel="self" type="application/rss+xml"/><item><title>Persistence</title><link>https://hortacloud.janelia.org/docs/development/systemoverview/persistence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hortacloud.janelia.org/docs/development/systemoverview/persistence/</guid><description>&lt;p>This section covers a basic overview of how Horta persists neurons, workspaces, samples and preferences.&lt;/p>
&lt;h1 id="asynchronous-vs-synchronous-saving">Asynchronous vs synchronous saving&lt;/h1>
&lt;p>The final persistence store for Horta is in MongoDB, a document database, whether or not the data being saved is asynchronous or synchronous. Most Horta data is saved synchronously; the purpose of the asynchronous saving is to:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Ease the burden on the annotator to constantly save their work&lt;/code>&lt;/li>
&lt;li>&lt;code>Share annotations in realtime with other annotators or machine algorithms working in the same workspace&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="persistence-flow">Persistence flow&lt;/h1>
&lt;p>All access to MongoDB is wrapped by a RESTful API, jacs-sync, with a number of endpoints for CRUD operations for TmWorkspace, TmSample, and TmNeuronMetadata. The basic class/component diagram is shown below. When a workspace is first loaded, it relies on NeuronModelAdapter to stream in parallel all the neuron annotations for that workspace into the client app. The following initialization steps are performed with the annotation data:&lt;/p></description></item><item><title>Tiled Imagery</title><link>https://hortacloud.janelia.org/docs/development/systemoverview/tileimagery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hortacloud.janelia.org/docs/development/systemoverview/tileimagery/</guid><description>&lt;h2 id="horta-2d">Horta 2D&lt;/h2>
&lt;p>Horta&amp;rsquo;s 2D and 3D viewer were originally 2 separate visualization packages, so the way that they load tile imagery is quite different. Horta2D was called LVV (Large Volume Viewer) and exclusively loads many 2D slices from a TIFF Octree at a specific resolution to produce a mosaic that fills the window. These 2D slices are retrieved from the jacs-sync REST API based off the current focus on the window.&lt;/p></description></item><item><title>Event Handling/Communication</title><link>https://hortacloud.janelia.org/docs/development/systemoverview/eventhandling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://hortacloud.janelia.org/docs/development/systemoverview/eventhandling/</guid><description>&lt;p>This section briefly covers how information is shared throughout the GUI in Horta&lt;/p>
&lt;h3 id="eventbus">EventBus&lt;/h3>
&lt;p>To preserve code independence between different modules in Horta, an EventBus from Google is used. This acts likes an internal publish/subscribe framework within the client, allowing methods to listen for certain events to happen. Events are sent asynchronously on the EventBus, so they are managed in a separate thread than the main AWT thread.&lt;/p>
&lt;p>In Horta, the EventBus is mainly used to communicate events that concern multiple GUI components. Events that are mostly concerned with communication within a GUI component are still managed using Listeners.&lt;/p></description></item></channel></rss>